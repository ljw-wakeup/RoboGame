import numpy as np
import cv2
import math
import copy
import time

cap = 0
def initpic():
	global cap 
	a = time.clock()
	cap = cv2.VideoCapture(1)
	while True :
		ret,frame = cap.read()
		cv2.imshow("init",frame)
		b = time.clock()
		if (b-a) > 5 :
			break
	return

def getpic():
	initpic()
	ret,frame = cap.read()
	cv2.imshow("capture", frame)
	cv2.imwrite("test.jpg",frame)
	cap.release()
	cv2.destroyAllWindows()
	return frame
	
def detectline(img):
	cv2.startWindowThread()
	cv2.namedWindow('input image',cv2.WINDOW_NORMAL)
	img = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    #resize
	resizeImg = cv2.resize(img,(320,240),interpolation = cv2.INTER_AREA)
	cv2.imshow('input image', resizeImg)
	cv2.waitKey(0)
#BINARY has three methods ,below is Otsu
#Gaussian
	blur = cv2.GaussianBlur(resizeImg,(11,11),0)
	ret, binary = cv2.threshold(blur,40,255,cv2.THRESH_BINARY)
#    binary = cv2.adaptiveThreshold(blur,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,11,2)
	binary = cv2.GaussianBlur(binary,(11,11),0)
	cv2.imshow('binary', binary)
	cv2.waitKey(0)
	xgrad = cv2.Sobel(binary,cv2.CV_16SC1,1,0)
	ygrad = cv2.Sobel(binary,cv2.CV_16SC1,0,1)
	edge_output = cv2.Canny(xgrad,ygrad,50,150)
	cv2.imshow('canny',edge_output)
	lines = cv2.HoughLinesP(edge_output,5, np.pi / 180, 30 ,minLineLength = 5, maxLineGap = 20)
	i = 0
	edge_output[:,:] = 0
	L = []
	for line in lines:
		i = i + 1
		x1,y1,x2,y2 = line[0]
		cv2.line(edge_output,(x1,y1),(x2,y2),(255,255,255),1,lineType = cv2.LINE_AA)
		cv2.imshow(str(i)+".jpg",edge_output)
		cv2.waitKey(0)
		if ( x2 - x1 ) == 0 :
			k = 0
			b = x1
			theta = 90
		else :
			k = float(y2-y1)/float(x2-x1)
			b = y1-k*x1
			theta = math.atan(k)*180.0/(math.pi)	    
		L.append([x1,y1,x2,y2,k,b,theta])
	print("originL", L)   
	return L
	
def linesort(L):
	Lsorted = sorted(L, key = lambda x:(x[6],x[4]))
	print("aftersorted", Lbsorted)
	Lsorted_length = len(Lsorted)
	for line in Lsorted:
		line.append(np.square(line[0]-line[2]) + np.square(line[1]-line[3]))
	#(x1,y1,x2,y2,k,b,theta,length)
	print("(x1,y1,x2,y2,k,b,theta,length)" , Lsorted)
	Lmerge_first = []
	i = 0
	while i < length:
		j = i + 1
		maxlong = 0
		while j < length:
			if abs(bsorted[i][6] - Lsorted[j][6]) < 5 and abs(Lsorted[i][5] - Lsorted[j][5])/math.sqrt(1+Lsorted[i][4] * Lsorted[j][4]) < 10 :
				if Lsorted[i][7] > maxlong :
					maxlong = Lsorted[i][7]
				j = j + 1
			else :
				break
		x = i
		maxlinelist = []
		while x < j :
			if Lsorted[x][7] > 0.6 * maxlong :
				maxlinelist.append(x)
			x += 1
		maxlinenum = len(maxlinelist)
		newline = [0,0,0,0,0,0,0,0]
		for item in maxlinelist :
			y = 0
			while y < 4 :
				newline[y] += Lsorted[item][y]
				y += 1
			y = 0
			while y < 4 :
				newline[y] = float(newline[y])/maxlinenum
				y += 1
			newline[4] = (newline[3]-newline[1])/(newline[2]-newline[0])
			newline[5] = newline[1] - newline[4] * newline[0]
			newline[6] = math.atan(newline[4])*180.0/(math.pi)
			newline[7] = np.square(newline[0]-newline[2]) + np.square(newline[1] - newline[3])    
			Lmerge_first.append(newline)
		i = j
#    print("Lmerge_first",Lmerge_first)
	return Lmerge_first
img = getpic()
L = detectline(img)
linesort(L)


