import numpy as np
import cv2
import math
import copy
import time

mode = 0
def detectline():
    img = cv2.imread('/home/helen/Documents/RoboGame/Cam/IMG_0792.JPG',0)
    cv2.startWindowThread()
    cv2.namedWindow('input image',cv2.WINDOW_NORMAL)
    ball = img[1000:3800,500:2600]

#resize
    ball = cv2.resize(ball,(160,240),interpolation = cv2.INTER_AREA)
#BINARY has three methods ,below is Otsu
#Gaussian
    blur = cv2.GaussianBlur(ball,(11,11),0)
# too slow: blur = cv2.bilateralFilter(img,3,70,70)
    ret,binary = cv2.threshold(blur,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
#cv2.imshow('input image', binary)
#cv2.waitKey(0)

# contour
    cv2.imwrite("binary.jpg",binary)
    contourimg,contours,hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)
#print("hierarchy is \n", hierarchy)
#print("contours",contours)

#make a contrast
    contrast = ball
    contrast[:,:]=0 
# the contours
    L = []
    for cnt in contours:
        perimeter = cv2.arcLength(cnt,False)
        if perimeter > 100 :
            print("perimeter", perimeter)	
	    for n in cnt:
                x = n[0][0]
	        y = n[0][1] 
                if x  > 2 and x < 158 and y > 3 and y < 237 :
		    contrast[y,x] = 255       
	    cv2.imwrite("outputnormal.jpg", contrast)
	    lines = cv2.HoughLinesP(contrast,5, np.pi / 180, 30 ,minLineLength = 5, maxLineGap = 20)
	    i = 0
	    contrast[:,:] = 0
	    for line in lines:
	        i = i + 1
	        x1,y1,x2,y2 = line[0]
	        cv2.line(contrast,(x1,y1),(x2,y2),(255,255,255),1,lineType = cv2.LINE_AA)
	        cv2.imwrite(str(i)+".jpg",contrast)
		if ( x2 - x1 ) == 0 :
		    k = 0
		    b = x1
		    theta = 90
		else :
		    k = float(y2-y1)/float(x2-x1)
 		    b = y1-k*x1
	            theta = math.atan(k)*180.0/(math.pi)	    
		L.append([x1,y1,x2,y2,k,b,theta])
		    
#	    print("originL", L)
    return L
	    
#the item in L include the x1,y1,x2,y2 in the line
		
def linesort(L):
    Lbsorted = sorted(L, key = lambda x:(x[6],x[4]))
#    print("aftersorted", Lbsorted)
    length = len(Lbsorted)
    for line in Lbsorted:
	line.append(np.square(line[0]-line[2]) + np.square(line[1]-line[3]))
#    print("Lbsorted" , Lbsorted)
    Lmerge = []
    i = 0
    while i < length:
	j = i + 1
	maxlong = 0
	while j < length:
    	    if abs(Lbsorted[i][6] - Lbsorted[j][6]) < 5 and abs(Lbsorted[i][5] - Lbsorted[j][5])/math.sqrt(1+Lbsorted[i][4] * Lbsorted[j][4]) < 10 :
		if Lbsorted[i][7] > maxlong :
		    maxlong = Lbsorted[i][7]
		j = j + 1
	    else :
		break
	x = i
	maxlinelist = []
        while x < j :
	    if Lbsorted[x][7] > 0.6 * maxlong :
		maxlinelist.append(x)
	    x += 1
	maxlinenum = len(maxlinelist)
	newline = [0,0,0,0,0,0,0,0]
	for item in maxlinelist :
	    y = 0
	    while y < 4 :
		newline[y] += Lbsorted[item][y]
		y += 1
        y = 0
	while y < 4 :
	    newline[y] = float(newline[y])/maxlinenum
            y += 1
        newline[4] = (newline[3]-newline[1])/(newline[2]-newline[0])
        newline[5] = newline[1] - newline[4] * newline[0]
	newline[6] = math.atan(newline[4])*180.0/(math.pi)
        newline[7] = np.square(newline[0]-newline[2]) + np.square(newline[1] - newline[3])    
        Lmerge.append(newline)
	i = j
#    print("Lmerge",Lmerge)
    return Lmerge

def orbitmerge(Lmerge):
    normal = []
    considerated = []
    length = len(Lmerge)
    i = 0
    while i < length :
	j = i + 1
	while j < length :
	    if abs(Lmerge[i][6] - Lmerge[j][6]) < 5 and abs(Lmerge[i][5] - Lmerge[j][5])/math.sqrt(1+Lmerge[i][4] * Lmerge[j][4]) < 50 :
		j += 1
	    else :
		break
	if j - i == 1 :
	    line = Lmerge[i][:]
	    considerated.append(line)
	else :
	    line = [0,0,0,0,0,0,0,0]
	    x = i
	    while x < j :
		line[0] += Lmerge[x][0]
		line[1] += Lmerge[x][1]
		line[2] += Lmerge[x][2]
		line[3] += Lmerge[x][3]
		x += 1
	    line[0] /= j-i
	    line[1] /= j-i
	    line[2] /= j-i
	    line[3] /= j-i
	    line[4] = (line[3]-line[1])/(line[2]-line[0])
	    line[5] = line[1] - line[4] * line[0]
	    line[6] = math.atan(line[4])*180.0/(math.pi)
            line[7] = np.square(line[0] - line[2]) + np.square(line[1] - line[3]) 
	    normal.append(line)
	i = j
#    print("normal", normal)
#    print("considerated", considerated)
    return normal, considerated

def calculateForMode(normal, considerated) :
    global mode
    verticle = 0
    verticlelist = []
    horizon = 0
    horizonlist = []
    for line in normal :
	if line[6] > 45 or line[6] < -45 :
	    verticle += 1
	    verticlelist.append(line)
        else :
	    horizon += 1
	    horizonlist.append(line)
    if mode == 0 :
	for line in verticlelist:
	    line.append((240 - line[5])/line[4] - 80)
	verticlelist = sorted(verticlelist, key = lambda x:abs(x[8]))
#        print(verticlelist)
	return verticlelist[0][8]
                    

        

	
	    
print(time.clock())
L = detectline()
print(time.clock())

LN = linesort(L)
print(time.clock())

normal,considerated = orbitmerge(LN)
print(time.clock())

index = calculateForMode(normal, considerated)

print(index)	
print(time.clock())
